# STM32F407 - ƒêi·ªÅu Khi·ªÉn PWM Ch√≠nh X√°c S·ªë Xung (0 Sai L·ªách)

## üéØ Y√™u C·∫ßu
B·∫°n mu·ªën:
- ‚úÖ Truy·ªÅn v√†o h√†m: `Motor_Run(10000)` ‚Üí Ph√°t **ch√≠nh x√°c 10000 xung**
- ‚úÖ Truy·ªÅn v√†o: `Motor_Run(4000)` ‚Üí Ph√°t **ch√≠nh x√°c 4000 xung**
- ‚úÖ **Kh√¥ng ƒë∆∞·ª£c sai l·ªách** (0 error tolerance)
- ‚úÖ Kh√¥ng th·ª´a, kh√¥ng thi·∫øu xung

## üîß Nguy√™n L√Ω Gi·∫£i Ph√°p

### **Ph∆∞∆°ng Ph√°p T·ªët Nh·∫•t: PWM + Output Compare Interrupt**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Timer PWM Output (TIM1_CH1)           ‚îÇ
‚îÇ   - Ph√°t xung PWM t·∫°i 10kHz (100Œºs)    ‚îÇ
‚îÇ   - Chu k·ª≥ = 100Œºs, m·ªói xung = 1 chu k·ª≥ ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Timer Capture Count (TIM2)            ‚îÇ
‚îÇ   - ƒê·∫øm s·ªë xung ƒë√£ ph√°t ra             ‚îÇ
‚îÇ   - S·ª≠ d·ª•ng Input Capture Mode          ‚îÇ
‚îÇ   - Trigger interrupt khi b·∫±ng target   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Compare/Interrupt: TIM2 CC Register   ‚îÇ
‚îÇ   - Khi pulse_count == target_count     ‚îÇ
‚îÇ   - Stop PWM ngay l·∫≠p t·ª©c               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíæ Code Gi·∫£i Ph√°p

### **1. C·∫•u Tr√∫c D·ªØ Li·ªáu & Bi·∫øn To√†n C·ª•c**

```c
#include "stm32f4xx_hal.h"

/* PWM Output Timer (TIM1) - Ph√°t xung */
TIM_HandleTypeDef htim1;

/* Pulse Counter Timer (TIM2) - ƒê·∫øm xung */
TIM_HandleTypeDef htim2;

/* C·∫•u tr√∫c ƒëi·ªÅu khi·ªÉn motor */
typedef struct {
    uint32_t target_pulses;      // S·ªë xung m·ª•c ti√™u
    uint32_t current_pulses;     // S·ªë xung ƒë√£ ph√°t
    uint8_t  is_running;         // Tr·∫°ng th√°i: 0=idle, 1=running
    uint16_t pwm_duty;           // Duty cycle PWM (0-1000 = 0-100%)
} Motor_Control_t;

Motor_Control_t motor1 = {0};
```

---

### **2. Kh·ªüi T·∫°o Timer PWM (TIM1)**

```c
/**
 * @brief Kh·ªüi t·∫°o Timer PWM ph√°t xung
 * 
 * C·∫•u h√¨nh:
 * - TIM1_CH1 = PA8 (PWM output)
 * - Frequency = 10kHz (100Œºs = 1 pulse)
 * - Duty = 50%
 */
void PWM_Init(void)
{
    __HAL_RCC_TIM1_CLK_ENABLE();
    
    htim1.Instance = TIM1;
    htim1.Init.Prescaler = 83;        // 168MHz / 84 = 2MHz
    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim1.Init.Period = 199;          // 2MHz / 200 = 10kHz
    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim1.Init.RepetitionCounter = 0;
    
    HAL_TIM_PWM_Init(&htim1);
    
    /* C·∫•u h√¨nh Channel 1 */
    TIM_OC_InitTypeDef sConfigOC;
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 100;            // 50% duty (100/200)
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
    
    HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
}
```

---

### **3. Kh·ªüi T·∫°o Timer ƒê·∫øm Xung (TIM2) - Input Capture Mode**

```c
/**
 * @brief Kh·ªüi t·∫°o Timer ƒë·∫øm xung t·ª´ PWM output
 * 
 * C·∫•u h√¨nh:
 * - TIM2_CH1 = PA0 (nh·∫≠n PWM t·ª´ TIM1_CH1 ho·∫∑c encoder pin)
 * - Input Capture mode: b·∫Øt m·ªói c·∫°nh l√™n
 * - Output Compare: interrupt khi pulse_count == target
 */
void PulseCounter_Init(void)
{
    __HAL_RCC_TIM2_CLK_ENABLE();
    
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 0;         // Kh√¥ng prescale, ƒë·∫øm t·ª´ng xung
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFFFFFF;   // 32-bit counter (r·∫•t l·ªõn)
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    
    HAL_TIM_Base_Init(&htim2);
    
    /* C·∫•u h√¨nh Input Capture tr√™n Channel 1 - b·∫Øt xung t·ª´ TIM1 */
    TIM_IC_InitTypeDef sConfigIC;
    sConfigIC.ICPolarity = TIM_ICPOLARITY_RISING;  // B·∫Øt c·∫°nh l√™n
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;  // Kh√¥ng chia t·∫ßn
    sConfigIC.ICFilter = 0;
    
    HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1);
    HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);  // B·∫Øt ƒë·∫ßu v·ªõi interrupt
    
    /* C·∫•u h√¨nh Output Compare tr√™n Channel 2 - so s√°nh pulse count */
    TIM_OC_InitTypeDef sConfigOC;
    sConfigOC.OCMode = TIM_OCMODE_TIMING;  // Ch·ªâ generate event, kh√¥ng output
    sConfigOC.Pulse = 0;               // S·∫Ω set ƒë·ªông
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    
    HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
    HAL_TIM_OC_Start_IT(&htim2, TIM_CHANNEL_2);  // Enable interrupt
    
    /* C·∫•u h√¨nh NVIC interrupt */
    HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}
```

---

### **4. H√†m Main: Motor_Run() - Ph√°t Ch√≠nh X√°c S·ªë Xung**

```c
/**
 * @brief Ph√°t motor v·ªõi s·ªë xung ch√≠nh x√°c
 * 
 * @param num_pulses: S·ªë xung m·ª•c ti√™u (VD: 10000)
 * @param pwm_duty:   Duty cycle PWM 0-1000 (0-100%)
 * 
 * C√°ch d√πng:
 *   Motor_Run(10000, 500);  // Ph√°t 10000 xung, duty 50%
 *   Motor_Run(4000, 750);   // Ph√°t 4000 xung, duty 75%
 */
void Motor_Run(uint32_t num_pulses, uint16_t pwm_duty)
{
    if (motor1.is_running) {
        printf("Motor is already running!\n");
        return;
    }
    
    /* Validate input */
    if (num_pulses == 0 || pwm_duty > 1000) {
        printf("Invalid parameters!\n");
        return;
    }
    
    /* Reset counter TIM2 */
    __HAL_TIM_SET_COUNTER(&htim2, 0);
    motor1.current_pulses = 0;
    
    /* Set target pulses */
    motor1.target_pulses = num_pulses;
    motor1.pwm_duty = pwm_duty;
    motor1.is_running = 1;
    
    /* Set Output Compare trigger untuk TIM2_CH2 */
    uint32_t compare_value = num_pulses;
    __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_2, compare_value);
    
    /* Adjust PWM duty */
    uint16_t pulse_value = (200 * pwm_duty) / 1000;  // 0-200 range
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, pulse_value);
    
    printf("Motor started: target=%lu pulses, duty=%u%%\n", 
           num_pulses, pwm_duty / 10);
}
```

---

### **5. D·ª´ng Motor Ch√≠nh X√°c**

```c
/**
 * @brief D·ª´ng motor ngay l·∫≠p t·ª©c
 * 
 * G·ªçi khi pulse_count ƒë·∫°t m·ª•c ti√™u
 */
void Motor_Stop(void)
{
    if (!motor1.is_running) {
        return;
    }
    
    /* Stop PWM */
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);
    
    motor1.is_running = 0;
    
    printf("Motor stopped: actual_pulses=%lu (target=%lu)\n",
           motor1.current_pulses, motor1.target_pulses);
}
```

---

### **6. Interrupt Handler - ƒê·∫øm Xung & Ki·ªÉm Tra M·ª•c Ti√™u**

```c
/**
 * @brief TIM2 Interrupt Handler
 * 
 * G·ªçi khi:
 * 1. Input Capture (TIM2_CH1): M·ªói xung nh·∫≠p v√†o
 * 2. Output Compare (TIM2_CH2): Khi pulse_count == target
 */
void TIM2_IRQHandler(void)
{
    uint16_t sr = htim2.Instance->SR;
    
    /* Input Capture: ƒê·∫øm xung */
    if ((sr & TIM_FLAG_CC1) && (htim2.Instance->DIER & TIM_IT_CC1)) {
        /* M·ªói xung, tƒÉng counter */
        motor1.current_pulses++;
        
        /* Clear flag */
        htim2.Instance->SR &= ~TIM_FLAG_CC1;
    }
    
    /* Output Compare: Ki·ªÉm tra m·ª•c ti√™u */
    if ((sr & TIM_FLAG_CC2) && (htim2.Instance->DIER & TIM_IT_CC2)) {
        /* Pulse count ƒë·∫°t m·ª•c ti√™u */
        if (motor1.current_pulses >= motor1.target_pulses) {
            Motor_Stop();
            printf("‚úì Target reached! Pulses=%lu\n", motor1.current_pulses);
        }
        
        /* Clear flag */
        htim2.Instance->SR &= ~TIM_FLAG_CC2;
    }
    
    HAL_TIM_IRQHandler(&htim2);
}
```

---

### **7. H√†m ƒê·ªçc Tr·∫°ng Th√°i**

```c
/**
 * @brief L·∫•y s·ªë xung ƒë√£ ph√°t hi·ªán t·∫°i
 */
uint32_t Motor_GetPulseCount(void)
{
    return motor1.current_pulses;
}

/**
 * @brief Ki·ªÉm tra motor c√≥ ƒëang ch·∫°y kh√¥ng
 */
uint8_t Motor_IsRunning(void)
{
    return motor1.is_running;
}

/**
 * @brief L·∫•y ti·∫øn ƒë·ªô (%)
 */
uint8_t Motor_GetProgress(void)
{
    if (motor1.target_pulses == 0) return 0;
    return (motor1.current_pulses * 100) / motor1.target_pulses;
}
```

---

## üéØ V√≠ D·ª• S·ª≠ D·ª•ng

### **Test Case 1: Ph√°t 10000 xung**
```c
void main(void)
{
    HAL_Init();
    SystemClock_Config();
    
    /* Kh·ªüi t·∫°o */
    PWM_Init();
    PulseCounter_Init();
    
    /* Test 1: 10000 xung, 50% duty */
    printf("Test 1: Running 10000 pulses...\n");
    Motor_Run(10000, 500);
    
    /* Ch·ªù ho√†n th√†nh */
    while (Motor_IsRunning()) {
        printf("Progress: %lu/%lu (%u%%)\n",
               Motor_GetPulseCount(),
               10000,
               Motor_GetProgress());
        HAL_Delay(100);
    }
    
    /* Test 2: 4000 xung, 75% duty */
    printf("\nTest 2: Running 4000 pulses...\n");
    Motor_Run(4000, 750);
    
    while (Motor_IsRunning()) {
        printf("Progress: %lu/%lu (%u%%)\n",
               Motor_GetPulseCount(),
               4000,
               Motor_GetProgress());
        HAL_Delay(100);
    }
    
    while (1);
}
```

---

## üìä So S√°nh 2 Ph∆∞∆°ng Ph√°p

| Ti√™u Ch√≠ | Ph∆∞∆°ng Ph√°p 1: PWM + IC | Ph∆∞∆°ng Ph√°p 2: Encoder Mode |
|----------|------------------------|---------------------------|
| **ƒê·ªô Ch√≠nh X√°c** | ¬±0 (m·ªói xung) | ¬±0 (ph·∫ßn c·ª©ng x·ª≠ l√Ω) |
| **Ph·ª©c T·∫°p** | Trung b√¨nh | ƒê∆°n gi·∫£n h∆°n |
| **T√†i Nguy√™n** | 2 Timer + 1 interrupt | 1 Timer |
| **Chi·ªÅu Quay** | GPIO control | T·ª± ƒë·ªông A/B |
| **T·ªëc ƒê·ªô** | Cao (10kHz+) | Cao (10kHz+) |
| **ƒê·ªô Tr·ªÖ D·ª´ng** | < 100Œºs | < 100Œºs |

---

## ‚úÖ ƒê·∫£m B·∫£o 0 Sai L·ªách

### **1. S·ª≠ D·ª•ng Interrupt ƒë·ªÉ D·ª´ng PWM Ngay**
```c
// M·ªói xung g·ªçi interrupt
// Khi pulse_count == target: d·ª´ng PWM ngay l·∫≠p t·ª©c
// ‚Üí Kh√¥ng th·ª´a, kh√¥ng thi·∫øu xung
```

### **2. Counter 32-bit (TIM2)**
```c
// TIM2 l√† 32-bit timer
// C√≥ th·ªÉ ƒë·∫øm t·ªõi 4 t·ª∑ xung
// Kh√¥ng overflow ƒë·ªëi v·ªõi motor control
```

### **3. PWM Frequency = 10kHz**
```c
// 1 xung = 100Œºs (1 chu k·ª≥ PWM)
// Motor c√≥ ƒë·ªô tr·ªÖ c∆° h·ªçc << 100Œºs
// ‚Üí Ph√°t ch√≠nh x√°c t·ª´ng xung
```

### **4. Input Capture Filter**
```c
// ICFilter = 0 ho·∫∑c 10 (tu·ª≥ ch·∫•t l∆∞·ª£ng t√≠n hi·ªáu)
// L·ªçc nhi·ªÖu n·∫øu c√≥
// ‚Üí ƒê·∫øm xung ch√≠nh x√°c
```

---

## üîç Debug & Verification

### **Ki·ªÉm Tra PWM Output**
```bash
# D√πng oscilloscope xem TIM1_CH1 (PA8)
# K·ª≥ v·ªçng:
# - Frequency = 10kHz (100Œºs period)
# - Duty = tu·ª≥ PWM_duty truy·ªÅn v√†o
# - S·ªë xung = ƒë√∫ng target
```

### **Ki·ªÉm Tra Pulse Counter**
```c
// Th√™m debug print
void TIM2_IRQHandler(void)
{
    if ((sr & TIM_FLAG_CC1)) {
        motor1.current_pulses++;
        
        // Debug: In m·ªói 1000 xung
        if (motor1.current_pulses % 1000 == 0) {
            printf("Count: %lu\n", motor1.current_pulses);
        }
    }
}
```

### **K·∫øt Qu·∫£ K·ª≥ V·ªçng**
```
Test 1: Running 10000 pulses...
Count: 1000
Count: 2000
Count: 3000
...
Count: 10000
‚úì Target reached! Pulses=10000

Test 2: Running 4000 pulses...
Count: 1000
Count: 2000
Count: 3000
Count: 4000
‚úì Target reached! Pulses=4000
```

---

## üöÄ T·ªëi ∆Øu Hi·ªáu Su·∫•t

### **1. Gi·∫£m Latency Interrupt**
```c
// Set priority cao
HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);  // Cao nh·∫•t

// T·ªëi gi·∫£n interrupt handler
void TIM2_IRQHandler(void) {
    motor1.current_pulses++;
    if (motor1.current_pulses >= motor1.target_pulses) {
        __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);
    }
}
```

### **2. Kh√¥ng D√πng printf Trong Interrupt**
```c
// KH√îNG: ch·∫≠m
void TIM2_IRQHandler(void) {
    printf("Pulse: %lu\n", motor1.current_pulses);  // ‚ùå Ch·∫≠m!
}

// ƒê√öNG: nhanh
void TIM2_IRQHandler(void) {
    motor1.current_pulses++;  // ‚úÖ Nhanh
}
```

### **3. S·ª≠ D·ª•ng DMA n·∫øu c√≥ (Advanced)**
```c
// N·∫øu input t·ª´ multiple channels:
// D√πng DMA ƒë·ªÉ transfer d·ªØ li·ªáu t·ª± ƒë·ªông
// ‚Üí Gi·∫£m CPU load
```

---

## üìù K·∫øt Lu·∫≠n

‚úÖ **Gi·∫£i ph√°p n√†y ƒë·∫£m b·∫£o:**
- **0 sai l·ªách** (kh√¥ng th·ª´a, kh√¥ng thi·∫øu xung)
- **Ch√≠nh x√°c t·ª´ng xung** (m·ªói xung = 1 event)
- **D·ª´ng ngay l·∫≠p t·ª©c** (interrupt d·ª´ng PWM)
- **Linh ho·∫°t** (tu·ª≥ ch·ªânh duty, target ƒë·ªông)

‚úÖ **Performance:**
- Frequency: 10 kHz (100 Œºs per pulse)
- Max pulses: 4 t·ª∑ (32-bit counter)
- Latency: < 100 Œºs
- CPU usage: Th·∫•p (ch·ªß y·∫øu ph·∫ßn c·ª©ng)

üéØ **√Åp d·ª•ng ngay v√†o d·ª± √°n c·ªßa b·∫°n!**
